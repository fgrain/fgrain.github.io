---
title: 剑指19-23
date: 2021-03-03 17:07:27
tags:
	- 算法
	- 剑指offer
---

### 19 顺时针打印矩阵

**题目描述**

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

**示例1**

输入：

```
[[1,2],[3,4]]
```

返回值：

```
[1,2,4,3]
```

<!-- more -->

**思路：**

设置4个边界值，判断上下左右是否越界，顺时针从数组外圈开始遍历，注意单行或单列的数组不能从右到左，从上到下遍历。

```c++
class Solution {
public:
    vector<int> printMatrix(vector<vector<int> > matrix) {
        int row=matrix.size();
        int col=matrix[0].size();
        vector<int> res;
        if(row==0||col==0) return res;
        int left=0,right=col-1,bottom=0,top=row-1;
        while(left<=right&&bottom<=top){
            for(int i=left;i<=right;i++)res.push_back(matrix[bottom][i]);
            for(int i=bottom+1;i<=top;i++)res.push_back(matrix[i][right]);
            if(bottom!=top)
                for(int i=right-1;i>=left;i--)res.push_back(matrix[top][i]);
            if(left!=right)
                for(int i=top-1;i>bottom;i--)res.push_back(matrix[i][left]);
            left++;right--;bottom++;top--;
        }
        return res;
    }
};
```

### 20 包含min函数的栈

**题目描述**

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O(1)）。

**思路：**

设置两个栈，一个正常压入每一个数，一个压入当前最小值，弹出操作时若两个栈顶元素相同则同时弹出，不同则只弹出第一个栈中元素。这样第二个栈栈顶元素始终为最小值

```c++
class Solution {
public:
    stack<int> s1,s2;
    void push(int value) {
        s1.push(value);
        if(s2.empty())s2.push(value);
        else if(value<=s2.top())s2.push(value);
    }
    void pop() {
        if(s1.top()==s2.top())s2.pop();
        s1.pop();
    }
    int top() {
        return s1.top();
    }
    int min() {
        return s2.top();
    }
};
```

### 21 栈的压入、弹出序列

**题目描述**

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

**示例1**

输入：

```
[1,2,3,4,5],[4,3,5,1,2]
```

返回值：

```
false
```

**思路：**

创建一个栈来进行压入弹出操作，遍历第一个数组将元素压入栈，直到栈顶元素和第二个栈中当前元素相同，栈顶元素弹出，第二个数组指针右移。若一切顺利最终栈中元素将全部弹出

```c++
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        stack<int> st;
        int i=0,j=0;
        for(i;i<pushV.size();i++){
            st.push(pushV[i]);
            while(!st.empty()&&st.top()==popV[j]){
                st.pop();
                j++;
            }
        }
        return st.empty();
    }
};
```

### 22 从上往下打印二叉树

**题目描述**

从上往下打印出二叉树的每个节点，同层节点从左至右打印。

**示例1**

输入：

```
{5,4,#,3,#,2,#,1}
```

返回值：

```
[5,4,3,2,1]
```

**思路：**

利用队列先入先出的特性，队首为当前节点，若当前节点的左右子树不为空则左右子树入队，队首出队，值填入结果数组中，循环遍历直到队列为空。

```c++
class Solution {
public:
    vector<int> PrintFromTopToBottom(TreeNode* root) {
        queue<TreeNode*> qu;
        vector<int> res;
        if(!root)return res;
        qu.push(root);
        while(!qu.empty()){
            if(qu.front()->left)qu.push(qu.front()->left);
            if(qu.front()->right)qu.push(qu.front()->right);
            res.push_back(qu.front()->val);
            qu.pop();
        }
        return res;
    }
};
```

### 23 二叉搜索树的后序遍历序列

**题目描述**

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。

**示例1**

输入：

```
[4,8,6,12,16,14,10]
```

返回值：

```
true
```

**思路：**

后序遍历的序列从后往前看就是根右左遍历的顺序，最后一个节点为根节点，剩下的数组分为两部分，一部分为左子树全部小于根节点，一部分为右子树全部大于根节点。递归判断每个子树是否符合条件

```c++
class Solution {
public:
    bool VerifySquenceOfBST(vector<int> sequence) {
        if(sequence.size()==0)return false;
        return dfs(sequence,0,sequence.size()-1);
    }
    
    bool dfs(vector<int> sequence,int l,int r){
        if(l>=r)return true;
        int i=l;
        while(sequence[i]<sequence[r])i++;//此时i为右子树最小的值
        int j=i;
        while(sequence[j]>sequence[r])j++;//判断右子树是否全部大于根节点
        if(j<r)return false;
        return dfs(sequence,i,r-1)&&dfs(sequence, 0, i-1);
    }
};
```

